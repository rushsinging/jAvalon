# Refactoring
## 第三章 代码中的坏味道
在本章中，主要描述了一系列的的应该重构的象征。其中针对每一种象征都会有一种或者数种解决方法，具体方法会在以后的章节内提到。
### 重复代码
* 如果只是单纯的的一个类里面有两个相似的函数，可以简单的提炼出来即可。
* 如果是兄弟子类中的方法，则在提炼后需要提升到超类中；如果方法有差异，则需要将相似部分提升到超类（可以用到模板方法），对差异部分分别处理
* 如果是两个不同的类有相似的代码，考虑提炼出另一个类。

### 过长函数
* 提炼函数
* 用查询代替临时元素
		
		double basePrice = _quantity * _itemPrice;
		if (basePrice > 1000){
			return basePrice * 0.8;
		}
		else {
			return basePrice * 0.9
		}
		
		---
		if (basePrice() > 1000){
			return basePrice() * 0.8;
		}
		else {
			return basePrice() * 0.9
		}
		double basePrice(){
			return _quantity * _itemPrice;
		}
* 分解条件表达式和循环，建议在开发过程中就开始这么做：
	* 良好的命名可以解释循环的作用
	* 逻辑清晰

### 过大的类
提炼出新类或者使用继承解决

### 过长参数列

* 参数队列对象化（python: `**kwargs`）
* 函数调用对象化

### 发散式变化
使用提炼类的方式将发散的变化集中到一个类里面。

### 霰弹式修改

* 使用移动方法和移动字段的方式将修改移动到一个类里面
* 内联类


### 依恋情结
定义：一个类里面的一个方法对其他类的方法或者数据比所在的类更感兴趣。解决方法是将这个方法移动到**合适**的位置。

扩展：依赖注入（DI，或者是控制反转IoC），当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。

### 数据泥团
* 合理抽象成对象
* 减少函数参数序列

### 基本类型偏执
多使用对象表达基本数据，高级语言中的模板特性可以多多使用。
	
	class T<type>{
		type a;
		type b;
		int c, d, e;
	}
	
### Switch惊悚现身
python没有switch不过可以用dict模拟

### 平行继承体系
指的是当你在一个类继承体系内增加一个类时，也需要在另一个继承体系里面增加一个类。

### 冗赘类
* 与超类合并
* 内联类

### 夸夸其谈未来性
### 令人迷惑的暂时字段
某些字段只被单一的函数使用到，其他的函数对他们没有任何兴趣。感觉大部分是因为*过大的类*的原因。

### 过度耦合的消息链
* 用函数调用缩短消息链的长度

### 中间人
中间人的过渡使用，尝试去掉中间人，和直接的对象打交道。

### 狎昵关系
* 移动数据和方法
* 去掉不必要的关联
* 抽象中间人
* 隐藏委托关系

### 异曲同工的类
### 不完整的库类
适配器模式

### 纯稚的数据类
### 被拒绝的馈赠
### 过多的注释
这些注释存在是因为代码很糟糕...

## 总结
* 重构不一定是在代码完成之后（如果时间允许）
* 面向接口，遵守最少知识原则，活用多态和设计模式（OO语言）。
