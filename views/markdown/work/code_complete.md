# High-Quality Routines 高质量的子程序

## 相关
* 构造子程序的步骤 9.3
* 可以工作的类 6
* 一般设计技术 5
* 软件架构 3.5

## 什么是子程序(routine)
子程序是为实现一个特定的目的而编写的可以被调用的方法或者过程。

子程序分布
e.g.  

* function in C++
* method in Java
* function procedure in VB 
* macro in C/C++
* function in python ...

一些不好的子程序写法：

	# 曾经的新浪微博的自动回复脚本
	def get_mention(): # get_mentions or get_mention_list
		'''
		拉取微博函数
		'''
		...
		return list
		
	# 数据库查询函数命名
	def get():
		pass
	def select():
		pass
	def search():
		pass
	
	# 现在的新浪微博自动回复…
	def add_guokr_question():
		'''
		将问题添加到果壳主张
		'''
		# 还会有拼接回复的代码
		# add_question
		return 
		
	# python code
	def do_something(data):
		# data 是什么类型
		do_something
		return 
		
	＃ 参数冗余,排序混乱
	def do_something(b, d, g, a,):
		return
		
	# C# 过多的函数重载
	int do_something(a, b, c, d, e){}
	int do_something(a, c){}
	int do_something(a, c, d){}
	int do_something(a, e){}
	
	# 应该保持一个最常用的和一个功能最常用的
	int do_something(a, b, c, d, e){}
	int do_something(a, b)

## 创建子程序的正当理由
* **降低复杂度** 更好的确认和发现问题
* **避免代码重复**
* 支持子类化
* 隐藏顺序
* 隐藏指针操作
* 提高可移植性
* **简化复杂的布尔判断**

        def is_something_true():
        	pass
        
        form.validate()
			
* 改善性能,很像降低复杂度这一特性
* 创建类的很多理由同样也是
    * 隔离复杂度
    * 隐藏实现细节
    * 限制变化所带来的影响
    * 隐藏全局数据
    * 形成中央控制点
    * 促成可复用的代码
    * 达成特定的目的

### 似乎过于简单而没有必要写成子程序的操作
写成子程序可以：

* 自我注解 提高可读性
* 简单的操作可能变成复杂的操作

        logger.error(error_msg)
		
开始的时候，日志纪录倒是没有明显的问题，不过随着需要纪录的东西增多，以及代码结构层次的混乱，在读代码和检查BUG时，繁多的日志纪录就会开始阻碍视线，甚至在完成debug后你会发现你不知道需要保留哪一部分日志，所以在末日计划后，我对新浪微博的自动回复脚本重构了一次，尽量减少每个子程序的工作，并用装饰器纪录日志。
	
    @logger


## 在子程序层上设计
内聚性：子程序中各种操作之间联系的紧密程度。  

内聚与耦合，得墨忒耳法则（最少知识法则）@程序员修炼之道：  
对于类内的函数而言，它只会调用4种方法：

1. 它自身的方法
2. 传入该方法的参数
3. 它自己创建的任何对象
4. 任何直接持有的组件

功能的内聚性

被认为不够理想的内聚性的分类：

* 顺序上的内聚性
* 通信上的内聚性
* 临时的内聚性
* 过程上的内聚性
* 逻辑上的内聚性
* 巧合的内聚性

## 好的子程序的名字
* 描述子程序所作的事情
* 避免无意义，模糊或者表述不清的动词
* 不要仅通过数字形成子程序的名字
* 根须需要确定程序名字的长度
* 给函数命名时需要对返回值有所描述
* 准确使用对仗词  
		
		add/remove  
		begin/end  
		created/destroy  
		first/last  
		...  
* 为常用操作确立命名规则

## 子程序可以写多长
一些例子

* 一个函数在10行以内
* basili和Perricone的研究发现 子程序的长度和错误量呈现反比（0-200）
* 子程序的长度和错误量无关，结构复杂度？
* 短小的子程序（<32）与较低的成本和错误率无关。而较长的子程序（>65）使得每行代码的成本下降
* 100-150的代码被修改的几率最低
* 最容易出错的是超过500行的代码
* ...

那么，建议是控制在100-200行，并且考虑到子程序的内聚性，嵌套层次，变量数量，决策点。

## 如何使用子程序参数

* 按照输入－输出－修改的顺序
* 考虑自建IN和OUT关键字（in C/C++）
* 如果几个子程序都用了类似的参数，应该让他们保持顺序一致。
* 使用所有的参数
* 把状态和出错变量放在最后
* 不要把子程序的参数用作工作变量
* 限制在7个以内
* 考虑对参数采用某种输入、修改、输出的命名规则
* 为子程序传递用以维持其接口抽象的变量或者对象
* 使用具名参数

## 使用函数时要特别考虑的问题
### 什么时候使用函数，什么时候使用过程
### 设置函数的返回值

## 宏子程序和内联子程序
* \#define in C风格代码
* inline in C 风格代码
