# High-Quality Routines 高质量的子程序

## 相关
* 构造子程序的步骤 9.3
* 可以工作的类 6
* 一般设计技术 5
* 软件架构 3.5

## 什么是子程序(routine)
子程序是为实现一个特定的目的而编写的可以被调用的方法或者过程。

e.g.  

* function in C++
* method in Java
* function procedure in VB 
* macro in C/C++
* function in python ...

## 创建子程序的正当理由
* 降低复杂度
* 避免代码重复
* 支持子类化
* 隐藏顺序
* 隐藏指针操作
* 提高可移植性
* 简化复杂的布尔判断
* 改善性能
* 创建类的很多理由同样也是
    * 隔离复杂度
    * 隐藏实现细节
    * 限制变化所带来的影响
    * 隐藏全局数据
    * 形成中央控制点
    * 促成可复用的代码
    * 达成特定的目的

### 似乎过于简单而没有必要写成子程序的操作
写成子程序可以：
* 自我注解 提高可读性
* 简单的操作可能变成复杂的操作


## 在子程序层上设计
内聚性：子程序中各种操作之间联系的紧密程度。  

内聚与耦合，得墨忒耳法则（最少知识法则）@程序员修炼之道：  
对于类内的函数而言，它只会调用4种方法：
1. 它自身的方法
2. 传入该方法的参数
3. 它自己创建的任何对象
4. 任何直接持有的组件


内聚性的分类：
* 功能的内聚性
* 顺序上的内聚性
* 通信上的内聚性
* 临时的内聚性
* 过程上的内聚性
* 逻辑上的内聚性
* 巧合的内聚性

## 好的则程序的名字
* 描述子程序所作的事情
* 避免无意义，模糊或者表述不清的动词
* 不要仅通过数字形成子程序的名字
* 根须需要确定程序名字的长度
* 给函数命名时需要对返回值有所描述
* 准确使用对仗词
* 为常用操作确立命名规则

## 子程序可以写多长
一些例子
* @开明 一个函数在10行以内
* basili和Perricone的研究发现 子程序的长度和错误量呈现反比（0-200）
* 子程序的长度和错误量无关，结构复杂度？
* 短小的子程序（<32）与较低的成本和错误率无关。而较长的子程序（>65）使得每行代码的成本下降
* 100-150的代码被修改的几率最低
* 最容易出错的是超过500行的代码
* ...

那么，建议是控制在100-200行，并且考虑到子程序的内聚性，嵌套层次，变量数量，决策点。

## 如何使用子程序参数

* 按照输入－输出－修改的顺序
* 考虑自建IN和OUT关键字（in C/C++）
* 如果几个子程序都用了类似的参数，应该让他们保持顺序一致。
* 使用所有的参数
* 把状态和出错变量放在最后
* 不要把子程序的参数用作工作变量
* 限制在7个以内
* 考虑对参数采用某种输入、修改、输出的命名规则
* 为子程序传递用以维持其接口抽象的变量或者对象
* 使用具名参数

## 使用函数时要特别考虑的问题
### 什么时候使用函数，什么时候使用过程
### 设置函数的返回值

## 宏子程序和内联子程序
* #define in C风格代码
* inline in C 风格代码
